{"ast":null,"code":"const WordNet = require('node-wordnet');\nconst wordnet = new WordNet();\n\n// Cache for synonyms to improve performance\nconst synonymCache = new Map();\n\n// Get synonyms for a word using WordNet\nconst getSynonyms = word => {\n  // Check cache first\n  if (synonymCache.has(word)) {\n    return synonymCache.get(word);\n  }\n  const synonyms = new Set();\n  try {\n    // Get all possible meanings (senses) of the word\n    const lookupResults = wordnet.lookup(word);\n    for (const result of lookupResults) {\n      // Add synonyms from each sense\n      if (result.synonyms) {\n        result.synonyms.forEach(synonym => {\n          if (synonym !== word) {\n            synonyms.add(synonym);\n          }\n        });\n      }\n\n      // Add antonyms if they exist\n      if (result.antonyms) {\n        result.antonyms.forEach(antonym => {\n          synonyms.add(antonym);\n        });\n      }\n    }\n  } catch (error) {\n    console.warn(`Warning: Could not find synonyms for word \"${word}\":`, error);\n  }\n\n  // Convert Set to Array and cache the result\n  const synonymArray = Array.from(synonyms);\n  synonymCache.set(word, synonymArray);\n  return synonymArray;\n};\n\n// Get the best synonym based on context\nconst getBestSynonym = (word, targetKeywords) => {\n  const synonyms = getSynonyms(word);\n\n  // If no synonyms found, return the original word\n  if (synonyms.length === 0) {\n    return word;\n  }\n\n  // Score each synonym based on how well it matches target keywords\n  const scoredSynonyms = synonyms.map(synonym => {\n    let score = 0;\n\n    // Check if the synonym is in target keywords\n    if (targetKeywords.includes(synonym)) {\n      score += 2;\n    }\n\n    // Check if any target keyword has this synonym\n    for (const targetKeyword of targetKeywords) {\n      const targetSynonyms = getSynonyms(targetKeyword);\n      if (targetSynonyms.includes(synonym)) {\n        score += 1;\n      }\n    }\n    return {\n      synonym,\n      score\n    };\n  });\n\n  // Sort by score and return the best match\n  scoredSynonyms.sort((a, b) => b.score - a.score);\n  return scoredSynonyms[0].synonym;\n};\n\n// Check if a word is a synonym of any target keyword\nconst isSynonymOfTarget = (word, targetKeywords) => {\n  // Check if the word is directly in target keywords\n  if (targetKeywords.includes(word)) {\n    return true;\n  }\n\n  // Check if the word is a synonym of any target keyword\n  for (const targetKeyword of targetKeywords) {\n    const targetSynonyms = getSynonyms(targetKeyword);\n    if (targetSynonyms.includes(word)) {\n      return true;\n    }\n  }\n  return false;\n};\nmodule.exports = {\n  getSynonyms,\n  getBestSynonym,\n  isSynonymOfTarget\n};","map":{"version":3,"names":["WordNet","require","wordnet","synonymCache","Map","getSynonyms","word","has","get","synonyms","Set","lookupResults","lookup","result","forEach","synonym","add","antonyms","antonym","error","console","warn","synonymArray","Array","from","set","getBestSynonym","targetKeywords","length","scoredSynonyms","map","score","includes","targetKeyword","targetSynonyms","sort","a","b","isSynonymOfTarget","module","exports"],"sources":["/var/home/dadmin/hackapp/src/utils/synonymUtils.js"],"sourcesContent":["const WordNet = require('node-wordnet');\n\nconst wordnet = new WordNet();\n\n// Cache for synonyms to improve performance\nconst synonymCache = new Map();\n\n// Get synonyms for a word using WordNet\nconst getSynonyms = (word) => {\n  // Check cache first\n  if (synonymCache.has(word)) {\n    return synonymCache.get(word);\n  }\n\n  const synonyms = new Set();\n  \n  try {\n    // Get all possible meanings (senses) of the word\n    const lookupResults = wordnet.lookup(word);\n    \n    for (const result of lookupResults) {\n      // Add synonyms from each sense\n      if (result.synonyms) {\n        result.synonyms.forEach(synonym => {\n          if (synonym !== word) {\n            synonyms.add(synonym);\n          }\n        });\n      }\n      \n      // Add antonyms if they exist\n      if (result.antonyms) {\n        result.antonyms.forEach(antonym => {\n          synonyms.add(antonym);\n        });\n      }\n    }\n  } catch (error) {\n    console.warn(`Warning: Could not find synonyms for word \"${word}\":`, error);\n  }\n\n  // Convert Set to Array and cache the result\n  const synonymArray = Array.from(synonyms);\n  synonymCache.set(word, synonymArray);\n  return synonymArray;\n};\n\n// Get the best synonym based on context\nconst getBestSynonym = (word, targetKeywords) => {\n  const synonyms = getSynonyms(word);\n  \n  // If no synonyms found, return the original word\n  if (synonyms.length === 0) {\n    return word;\n  }\n\n  // Score each synonym based on how well it matches target keywords\n  const scoredSynonyms = synonyms.map(synonym => {\n    let score = 0;\n    \n    // Check if the synonym is in target keywords\n    if (targetKeywords.includes(synonym)) {\n      score += 2;\n    }\n    \n    // Check if any target keyword has this synonym\n    for (const targetKeyword of targetKeywords) {\n      const targetSynonyms = getSynonyms(targetKeyword);\n      if (targetSynonyms.includes(synonym)) {\n        score += 1;\n      }\n    }\n    \n    return { synonym, score };\n  });\n\n  // Sort by score and return the best match\n  scoredSynonyms.sort((a, b) => b.score - a.score);\n  return scoredSynonyms[0].synonym;\n};\n\n// Check if a word is a synonym of any target keyword\nconst isSynonymOfTarget = (word, targetKeywords) => {\n  // Check if the word is directly in target keywords\n  if (targetKeywords.includes(word)) {\n    return true;\n  }\n\n  // Check if the word is a synonym of any target keyword\n  for (const targetKeyword of targetKeywords) {\n    const targetSynonyms = getSynonyms(targetKeyword);\n    if (targetSynonyms.includes(word)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  getSynonyms,\n  getBestSynonym,\n  isSynonymOfTarget\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}